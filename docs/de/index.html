<!DOCTYPE html>
<html lang="de-DE">
<head>
	<!-- Primary Meta Tags -->
	<title>WiFi-Thermostat - ESP8266 / ESP32 - Webserver - Kesselsteuerung im Automatikmodus mit Hysterese / manueller Steuerung</title>
	<meta name="description" content="Raumthermostat entwickelt auf der Espressif-Plattform - ESP8266 / ESP32. Thermostat für Hausheizung mit Gaskesselsteuerung.">
	<meta name="keywords" content="termostat, digitálny, arduino ide, wemos d1 mini, nodemcu, wifi, esp8266, vykurovanie, kúrenie, wifimanager, webserver, socket, http, web, ip, ipv4, ds18b20, onewire, 1-wire, esp32, nodemcu">
	<!-- Open Graph / Facebook -->
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://martinius96.github.io/WiFi-termostat/de/">
	<meta property="og:title" content="WiFi-Thermostat - ESP8266 / ESP32 - Webserver - Kesselsteuerung im Automatikmodus mit Hysterese / manueller Steuerung">
	<meta property="og:description" content="Raumthermostat entwickelt auf der Espressif-Plattform - ESP8266 / ESP32. Thermostat für Hausheizung mit Gaskesselsteuerung.">

	<!-- Twitter -->
	<meta property="twitter:card" content="summary_large_image">
	<meta property="twitter:url" content="https://martinius96.github.io/WiFi-termostat/de/">
	<meta property="twitter:title" content="WiFi-Thermostat - ESP8266 / ESP32 - Webserver - Kesselsteuerung im Automatikmodus mit Hysterese / manueller Steuerung">
	<meta property="twitter:description" content="Raumthermostat entwickelt auf der Espressif-Plattform - ESP8266 / ESP32. Thermostat für Hausheizung mit Gaskesselsteuerung.">
	
	<link rel="icon" type="image/png" href="favicon.png">
	<link rel="sitemap" type="application/xml" title="Sitemap" href="../sitemap.xml" />
	<meta name="google-site-verification" content="UwZZh2EXv3iWUAi_1Z0hLxVCz6ySJ4UdY_BPoLtejwo" />    	
	<meta property='fb:admins' content='100001242570317'>
    	<meta charset="utf-8">
    	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
	<script type="text/javascript">
    		window.smartlook||(function(d) {
    			var o=smartlook=function(){ o.api.push(arguments)},h=d.getElementsByTagName('head')[0];
    			var c=d.createElement('script');o.api=new Array();c.async=true;c.type='text/javascript';
    			c.charset='utf-8';c.src='https://rec.smartlook.com/recorder.js';h.appendChild(c);
    		})(document);
    		smartlook('init', 'db50efe9fff280a17db52b82be221240cbbd3dbe');
	</script>    
		<style>
	#right {
  position: absolute;
  right: 0px;
}
	</style>
</head>
<body>
	<div class="container">
  		<div class="row">
    			<div class="col-sm-12">
<nav class="navbar navbar-inverse">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="index.html">WiFi Thermostat</a>
    </div>
    <ul class="nav navbar-nav">
      	<li class="active"><a href="index.html">Überblick</a></li>
	<li><a href="zapojenie.html">Beteiligung</a></li>      
	<li class=""><a href="spustenie.html">WLAN-Thermostat starten</a></li>
  	<li><a href="json_client.html">JSON-Client</a></li>
      	<li><a href="kontakt.html">Kontakt</a></li>
<a href="../index.html"><img src="https://futbalovysen.sk/wp-content/uploads/slovakia.png" alt="Slovak flag.png, 2,2kB" title="Slovakia" height="32" width="32"></a>	
<a href="../en/index.html"><img src="https://i2.wp.com/facsusa.com/wp-content/uploads/2017/05/Flag-of-England.png?ssl=1" alt="English.png, 2,2kB" title="English" height="32" width="32"></a>
	<li style="float: right; "><a href="https://martinius96.github.io/termostat-ethernet/de/" class="btn btn-danger" role="button" title="Ändern Sie das Projekt in einen Ethernet-Thermostat"><img src="https://www.flaticon.com/svg/static/icons/svg/908/908547.svg" width=16px height=16px> <font color="white">Ethernet-Thermostat</font></a></li>
    </ul>
  </div>
</nav>  
<div class="alert alert-success">
	<strong>WiFi-Thermostat-Projekt-Repository mit Maschinencodes für die Zielplattform ESP8266 und ESP32: </strong><a href="https://github.com/martinius96/WiFi-termostat/tree/main/firmware">Firmware</a>
</div>	
<span class="label label-default">ESP8266</span>
<span class="label label-primary">ESP32</span>
<span class="label label-success">WiFi</span>
<span class="label label-info">DS18B20</span>
<span class="label label-warning">OneWire</span>
<span class="label label-danger">Dallas</span>
<span class="label label-default">HTML</span>
<span class="label label-primary">Webserver</span>
<span class="label label-success">WebSocket</span>
<span class="label label-info">JSON</span>
<span class="label label-warning">mDNS</span>	
<span class="label label-danger">UART</span>					
  <div class="row">
  <div class="col-sm-4"><center><img src="https://i.imgur.com/koSyFuW.png" width="128px" height="128px" style="border-radius: 50%;" alt="Mikrocontroller steuern NodeMCU v2 / v3 Lolin - ESP8266-12E / ESP8266-12F" title="Mikrocontroller steuern NodeMCU v2 / v3 Lolin - ESP8266-12E / ESP8266-12F"><br><b>NodeMCU (ESP8266)</b></center></div>
  <div class="col-sm-4"><center><img src="https://i.imgur.com/FV9xi6K.png" width="128px" height="128px" style="border-radius: 50%;" alt="Mikrocontroller steuern Wemos D1 Mini - ESP8266-12E / ESP8266-12F" title="Mikrocontroller steuern Wemos D1 Mini - ESP8266-12E / ESP8266-12F"><br><b>Wemos D1 Mini (ESP8266)</b></center></div>
  <div class="col-sm-4"><center><img src="https://i.imgur.com/BczG03b.png" width="128px" height="128px" style="border-radius: 50%;" alt="Mikrocontroller steuernr ESP32 Devkit V1 - ESP-WROOM-32 / ESP32-S" title="Mikrocontroller steuern ESP32 Devkit V1 - ESP-WROOM-32 / ESP32-S"><br><b>ESP32 DevKit</b></center></div>
</div>					
<hr><center><h2>WiFi Thermostat - ESP8266 / ESP32</h2></center><hr>
<p style="text-align: justify;">
Die Softwareimplementierung ist für Mikrocontroller-Plattformen des Herstellers Espressif Systems mit WiFi-Konnektivität ausgelegt.
Unterstützte WiFi (2,4 GHz) ESP8266- und ESP32-Mikrocontroller.
Der WiFi-Thermostat ist über das LAN-Netzwerk, in dem er sich befindet, zugänglich, während er mit einer Weboberfläche ausgestattet ist, die dazu dient, alle Elemente des Thermostats zu konfigurieren und gleichzeitig die aktuellen Zustände zu visualisieren.
Der Thermostat regelt den Kessel auf Basis der gemessenen Solltemperatur und Hysterese unabhängig von der Webapplikation, die zur Konfiguration und Entscheidungsschwelle des Thermostats dient.
Neben der Verfügbarkeit des Thermostats unter einer bestimmten IP-Adresse kann der Thermostat mit einem mDNS-Record ergänzt werden, der innerhalb dieses Multicast-Dienstes eine nur im LAN-Netzwerk erreichbare lokale Domain (hostname.local) generiert.
Die Konfiguration des Thermostats (aus Sicht der Konnektivität) im Heim-WLAN-LAN-Netzwerk wird durch den WiFiManager gesichert, der Daten über das WLAN-Netzwerk (SSID und Passwort) im Flash-Speicher des Mikrocontrollers speichert.
Die Speicherung erfolgt einmalig und das Gerät merkt sich die Konfiguration dauerhaft. Nach dem Herstellen der Konnektivität (Zuweisung einer IP-Adresse vom Router Ihres WLAN-Heimnetzwerks) kann der Thermostat vollständig verwendet werden.
Der HTTP-Webserver, der auf dem ESP8266 / ESP32-Mikrocontroller läuft, ermöglicht das Ausführen mehrerer unabhängiger HTML-Seiten, die informativ oder sogar funktional sein können.
</p>
<b>In Bezug auf die Hardware verwendet das Projekt:</b>
<li>ESP8266 / ESP32</li>
<li>Temperatursensor DS18B20 am OneWire-Bus</li>
<li>Relais SRD-5VDC-SL-C / OMRON G3MB-202P zur Kesselschaltung (Active-LOW-Signal)</li>
<hr>
<b> HTML-Seiten mit ESP8266 / ESP32: </b>
<li> <b> / </b> - Grundseite mit Formular, aktueller Logikausgang für das Relais, aktuelle und Solltemperatur, Hysterese </li>
<li> <b> /action.html </b> - verarbeitet Werte aus dem Formular, schreibt sie in den emulierten EEPROM-Speicher, leitet den Benutzer zurück zur Stammseite </li>
<li> <b> /get_data.json </b> - verteilt Daten zur aktuellen Temperatur, Referenztemperatur und Hysterese an Dritte (Computer, Mikrocontroller, anderer Client ...) im JSON-Format - kann mit dem Beispiel verwendet werden JSON-Client, der Daten an MQTT Broker senden kann, zum Beispiel an die Hausautomation </li>
<hr>
<b> Erweitert mit HTML-Seiten in einer experimentellen Version mit manuellem Modus, falls vorhanden: </b>
<li> <b> /on.html </b> - Ausgabe im manuellen Modus dauerhaft einschalten </li>
<li> <b> /vyp.html </b> - Ausgabe im manuellen Modus dauerhaft deaktivieren </li>
<li> <b> /automat.html </b> - Modus auf Automatik ändern (verwendet Hysterese und Zieltemperatur) </li>
<li> <b> /manual.html </b> - Wechseln Sie in den manuellen Modus (permanente EIN / AUS-Hardsteuerung) </li>
<hr>	
<p style="text-align: justify;">		
<b> Die Auflösung des DS18B20 Sensors während der Messung beträgt 12 Bit, was durch die Temperaturauflösung bei 0,0625 °C angezeigt wird, was ebenfalls ein minimaler Schritt zwischen den verschiedenen Messwerten ist.
Daten über den OneWire-Bus können bei Bedarf in 500 bis 1000 ms an den Mikrocontroller zurückgesendet werden, je nach Anzahl der Sensoren, Buslänge. </b>
Das im Projekt verwendete elektromagnetische Relais SRD-5VDC-SL-C ermöglicht das Schalten bis 10A bei 230V - Leistung 2300W.
Beim Schalten eines Gleichstromkreises (Last) können 300W (10A bei 30V DC) geschaltet werden.
Alternativ ist das OMRON G3MB-202P SSR-Relais voll kompatibel zum Schaltplan, der nur für nicht induktive Lasten und ausschließlich für Wechselstromkreise geeignet ist.
Maximale Schaltleistung 460W (230V, 2A). <b> Der Thermostat kann das ganze Jahr über verwendet werden. Im Falle einer unnötigen Steuerung ist es möglich, den Ausgang physisch zu trennen und den Thermostat als WLAN-Thermometer zu verwenden, um Daten aus dem Raum zu erhalten, in dem er sich befindet. </b>
</p>
<hr>
<p style="text-align: justify;">
Bei Firmware mit Unterstützung für die manuelle Steuerung des GPIO-Ausgangs des ESP-Mikrocontrollers kann der Thermostat physisch ausgeschaltet werden, ohne ihn von der Relaisklemme trennen zu müssen.
Die Thermostatlogik wird unabhängig vom Webserver und angeschlossenen Clients alle 10 Sekunden ausgeführt, für die Ausführung ist keine Keep-Alive-Verbindung erforderlich.
Bei jeder Ausführung der Logik schreibt der Thermostat auch Informationen über die aktuelle IP-Adresse oder den mDNS-Record (bei Verwendung mit mDNS-Firmware) auf den UART-Thermostat und gibt so dem Benutzer Auskunft darüber, wo der Thermostat mit seinem Webinterface im LAN erreichbar ist Netzwerk.
Darüber hinaus listet es auch den dynamischen freien Speicher - HEAP, der von 40 bis 44 kB reicht, sowie den aktuellen Status der Ausgabe mit Benachrichtigung über die Änderung, falls sie auftritt -> (wenn die Entscheidungsschwelle nach + oder nach - fließt) ).
<b> Die 3V3-GPIO-Betriebslogik der ESP8266- und ESP32-Mikrocontroller reicht für ein digitales Änderungssignal aus, aber das Relais muss mit 5 V von VUSB bzw. VIN versorgt werden. </b>
</p>
<b> Die Webschnittstelle des WiFi-Thermostats ermöglicht Ihnen: </b>
<li> Sehen Sie in Echtzeit die Temperatur des DS18B20-Sensors, die Betriebszeit des Geräts, den Ausgabewert mit dynamischer Änderung, die aktuell eingestellten Konfigurationsdaten für den Thermostat, d. Solltemperatur und Hysterese </li>
<li>Ändern Sie die Ziel-(Referenz-)Temperatur <del> im Bereich von 5 bis 50 °C in Schritten von 0,25 °C </del> </li>
<li> Ändern <del> Hysterese von 0 bis 10 ° C in Schritten von 0,25 ° C </del> </li>
<div class="alert alert-danger">
  <strong>Die Programmimplementierung eines Thermostats mit automatischer und manueller Leistungsregelung ist experimentell!</strong>
</div>
<b> Kessel EIN / AUS-Steuerung - Automatikmodus: </b>
<li>Beispiel für EIN / AUS der Heizungssteuerung - <font color = "red"> VISUALISIERUNG IST NICHT TEIL DES PROJEKTS </font> </li>
<li>Der Kessel ist aktiv, solange die Solltemperatur + Hysterese erreicht ist </li>
<li> Die Visualisierung von Wassertemperaturen zeigt die sogenannte Heizlauf und anschließendes Abkühlen des Wassers bis die Heizung wieder aktiviert wird, wenn die gemessene Temperatur unter der eingestellten Solltemperatur liegt - Hysterese </li>
<img src="https://i.imgur.com/IDWLuOr.png" style="display: block; max-width: 100%; height: auto;" alt="ZAP/VYP regulácia kotla s hysterézou" title="ZAP/VYP regulácia kotla s hysterézou">   
<p style="text-align: justify;">
<b> In der Basisversion des WiFi-Thermostats (ohne mDNS-Aufzeichnung) wurde ein manueller Steuermodus (hart EIN / AUS) implementiert mit der Möglichkeit zwischen manuellem und automatischem Modus umzuschalten. </b>
Die Weboberfläche ist für größere und kleinere Bildschirme ausgelegt. Es ist reaktionsschnell und unterstützt hochauflösende Breitbild-Bildschirme sowie mobile Geräte.
Die Schnittstelle verwendet importierte CSS-Stile des Bootstrap-Frameworks von einem externen CDN-Server, der das clientseitige Gerät lädt, wenn eine Seite geöffnet wird, die auf ESP ausgeführt wird.
Durch den Import von CSS-Stilen von einem externen Server wird die Strom- und Speicherbelastung des Mikrocontrollers reduziert.
</p>
<center><img src="https://i.imgur.com/8shZ0K3.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi termostat - webové rozhranie vizualizované v systéme Android - Chrome" title="WiFi termostat - webové rozhranie vizualizované v systéme Android - Chrome"></center>   		
<hr>
<p style="text-align: justify;">
Um die eingestellten Werte des Thermostats auch nach einem Stromausfall beizubehalten, werden diese im EEPROM-Speicher ESP gespeichert, der im Flash-Speicher emuliert wird, da die Plattform keinen physikalischen EEPROM-Chip (Speicher) besitzt.
Referenztemperatur auf Offset 10, Hysterese auf Offset 100. Jeder der Werte belegt maximal 5B im EEPROM-Speicher + das Endezeichen.
Die Daten werden erst beim Senden des HTML-Formulars überschrieben, der Betrieb des Thermostats schont den EEPROM-Speicher für maximale Haltbarkeit.
Der Zustand des Ausgangs existiert nur im RAM-Speicher, wo er bei der Änderung überschrieben wird. Der Wert wird nicht im emulierten EEPROM-Speicher im Flash-Speicher abgelegt.
</p>
<hr>
<p style="text-align: justify;">
Wenn das Gerät beim ersten Start nichts auf den genannten EEPROM-Offsets gespeichert hat, wird das automatische Schreiben mit Standardwerten durchgeführt - Referenz: 20,25 ° C, Hysterese 0,00 ° C. Dadurch wird sichergestellt, dass der Thermostat auf Mikrocontrollern arbeiten kann, die nichts im EEPROM-Speicher geschrieben haben - ausfallsichere Lösung.
ESP8266 und ESP32 verwenden die Funktion EEPROM.put(), um in den EEPROM-Speicher zu schreiben, der jeden Datentyp unterstützt, und EEPROM.commit(), um das Schreiben in den Ziel-Offset zu bestätigen.
Die Implementierung verwendet den Datentyp float() für eine 32-Bit-Zahl, die im EEPROM gespeichert wird und zur Referenz-(Soll-)Temperatur sowie Hysterese gehört.
Mit dem Refresh-Meta-Tag aktualisiert der Webserver alle 30 Sekunden die gesamte HTML-Seite und die JavaScript-Zeit bis zum Refresh wird ebenfalls per Javascript in die HTML-Seite geschrieben.
Zu diesem Zeitpunkt ist es notwendig, die Änderung für den Thermostaten zu schreiben, da sonst die Eingabefenster für numerische Eingaben in das Formular beim Aktualisieren der Seite zurückgesetzt werden.
Da die eingebaute Ethernet-Bibliothek die Verwendung eines asynchronen Webservers nicht beinhaltet (der beispielsweise mit den Espressif ESP8266 / ESP32-Mikrocontrollern verwendet werden kann), ist es erforderlich, die gesamte Seite neu zu schreiben, da diese Implementierung 1:1 ist mit dem originalen Ethernet-Thermostat.
</p>
<hr>
<p style="text-align: justify;">
Die sich hauptsächlich ändernden dynamischen Daten sind der aktuelle Wert der Ausgabe - <b> <font color = "# 27AE60"> Zapnutý (ON) </font> </b> / <b> <font color = "red"> Vypnutý (OFF) </font> </b>, die den Bediener über den aktuellen Zustand der Ausgabe zusammen mit der Farbcodierung informiert.
Da die Systemlogik unabhängig vom Webserver ausgeführt wird, kann sich die Ausgabe bereits in einem anderen Zustand befinden als aktuell in der Webanwendung aufgelistet. Die Ausgabeänderung wird z. B. sofort auf den UART-Monitor geschrieben.
Auf der Website des Thermostats findet der Benutzer auch Informationen über die Betriebszeit des Geräts (wie lange es in Betrieb war), d. Zeit in Tagen, Stunden, Minuten und Sekunden. <b>Der Thermostat ist nur für Innentemperaturen gedacht!</b> (über 0°C), an die die Systemlogik angepasst ist!
Der Thermostat kann verwendet werden, um einen vorhandenen Raumthermostat zu ersetzen, die Heizung im Aquarium / Terrarium kann vorübergehend ersetzt werden, um eine konstante Temperatur zu halten.
</p>
<div class="alert alert-danger">
	<strong>Der Autor des WiFi-Thermostats ist nicht verantwortlich für die Funktionalität des Thermostats, Kesselausfall, Stromschlag aufgrund einer unsachgemäßen Installation des Thermostats im Netzwerk. </strong> Der Thermostat wird unter der MIT-Lizenz vertrieben.
</div>	
<b> Hauptseite zur Änderung der Zieltemperatur und der Hysterese - Demo auf: </b>
<div class="alert alert-info">
	<strong> Beispieldaten </strong>
<li> <b>Zieltemperatur: </b>22,75 °C</li>
<li> <b> Hysterese: </b> 0,25 ° C </li>
<li> <b>Messdaten: </b> 21,59 ° C </li>
<li> <b> Ausgabe: </b>  <font color="#27AE60">Zapnutý (ON)</font></li>
	<hr>
	<p style="text-align: justify;">
		Der Thermostat heizt ab einer gemessenen Temperatur von 22,49°C und darunter.
Wenn die Temperatur 23,01 ° C erreicht, wird der Ausgang ausgeschaltet, das Melderelais öffnet und der Gaskessel hört auf zu heizen.
Das Aufheizen und Abkühlen des Raumes, in dem die Messungen durchgeführt werden, erfolgt. Der Thermostat wird erst wieder aktiviert, wenn die Temperatur 22,49 ° C oder niedriger erreicht.
	</p>	
</div>

<b>Hauptseite zur Änderung der Solltemperatur und Hysterese:</b>
<img src="https://i.imgur.com/YX7W2Z8.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi termostat - Hlavný prehľad s modifikáciou cieľovej teploty a hysterézy - Vypnutý" title="WiFi termostat - Hlavný prehľad s modifikáciou cieľovej teploty a hysterézy - Vypnutý">        			

<b>Verarbeitungsprozess der eingegebenen Daten (Nutzerumleitung):</b>
<img src="https://i.imgur.com/ZptC0UR.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi termostat - spracovanie údajov z HTML formulára" title="WiFi termostat - spracovanie údajov z HTML formulára">        			

<b>JSON-Webserverausgabe im Browser / Client über Websocket:</b>
<center><img src="https://i.imgur.com/iqxV12k.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi termostat - JSON output" title="WiFi termostat - JSON output"></center>        		

<b>Ausgabe an UART-Monitor - Systemlogik + IP-Adresse einstellen, mDNS-Record:</b>
<center>
<img src="https://i.imgur.com/f1mF6Fk.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi termostat - UART - ESP8266 - mDNS záznam" title="WiFi termostat - UART - ESP8266 - mDNS záznam">
<img src="https://i.imgur.com/rAfC2iJ.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi termostat - UART - ESP32 - výstup - ovládanie kotla" title="WiFi termostat - UART - ESP32 - výstup - ovládanie kotla">
</center>        		
<div class="alert alert-info">
<b> Eine erweiterte Version des WiFi-Thermostats umfasst: </b>
<li> Bearbeitbarer Quellcode (.ino) </li>
<li> Verfügbare Sensoren SHT21, SHT31, DHT22, BME280, BMP280 für die Kesselsteuerung </li>
<li> Kühlmodus (inverse Logik zum Heizthermostat) </li>
<li> Basic OTA, OTA Web Updater, Eleganter Remote OTA </li>
<li> Möglichkeit, die Ausgabe über Callbacks zu steuern, die von UDP-Datagrammen über UDP-Clients (Packet Sender) aufgerufen werden. </li>
<li> Interaktion mit Amazon Alexa Echo Dot mit der Möglichkeit der Sprachsteuerung des Thermostats (UDP-Rückrufe) </li>
<li> Möglichkeit zur Veröffentlichung von Daten an MQTT Broker / per HTTP / HTTPS-Anfrage an einen entfernten Webserver mit Datenspeicherung in einer MySQL-Datenbank (ohne JSON-Client) </li>
</div>
<hr>
<h3><font color="#C0392B">Beispielanweisung im JSON-Format</font></h3>
<li> Fähigkeit, JSON-Clients zu verarbeiten (mit kompatibler Firmware für Arduino + Ethernet / ESP8266 / ESP32 - im Repository verfügbar) </li>
<li> Möglichkeit, Daten an MQTT Broker zu senden und an andere Clients zu verteilen, die das Zielthema abonnieren können </li>
<li> Fähigkeit, das JSON-Format von anderen Clients zu lesen - JSON-Parser, Editor, Viewer und andere ... </li>
<div class="alert alert-danger">
	{<br>
		"Hysteresis":0.25,<br>
		"Target_Temperature":21.75,<br>
		"Actual_Temperature":21.43<br>
	}
</div>
<h3><font color="#2ECC71">Thermostat - Quellcode</font></h3>
<li>Thermostatlogik in minimaler Implementierung, ohne Webserver, WiFi-Konnektivität und emuliertem EEPROM-Speicher - allgemeine Implementierung </li>
<li> Muster für Ethernet- und WiFi-Thermostat für alle Mikrocontroller - Arduino, ESP8266, ESP32 mit demselben Quellcode </li>
<pre style="background-color:#2ECC71;">
//Projekt: Minimale Implementierung - Thermostat
//Autor: Martin Chlebovec
//Hardware: Arduino / ESP8266 / ESP32 + DS18B20 (1x OneWire-Bus)
//Überprüfung: 23. Mar. 2020

#include &lt;OneWire.h>
#include &lt;DallasTemperature.h>

#define ONE_WIRE_BUS 23 //datovy vovod OneWire zbernice na pin D23
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensorsA(&oneWire);
float nastavena_teplota = 24.50;
float hystereza = 0.50;
//float hystereza2 = 0.50;
const int rele = 6;
//const int rele2 = 7;
unsigned long timer = 0;
unsigned long interval = 15000; //ako casto chceme logiku spustit --> v ms (milisekundy)
void setup() {
  sensorsA.begin();
  Serial.begin(115200);
  Serial.println("UART ready");
  pinMode(rele, OUTPUT);
  // pinMode(rele2, OUTPUT);
}

void loop() {
  if ((millis() - timer) >= interval || timer == 0) {
    timer = millis();
    sensorsA.requestTemperatures();
    delay(2000); //cakame na teploty
    float  teplota1 = sensorsA.getTempCByIndex(0);
    //float  teplota2 = sensorsA.getTempCByIndex(1);
    float rozdiel = nastavena_teplota - teplota1;
    if (rozdiel > hystereza) {
      digitalWrite(rele, HIGH); //zopnutie rele
      Serial.println("Rele bolo zopnute - Vystup aktivny");
    } else if (rozdiel &lt; (-1 * hystereza)) {
      digitalWrite(rele, LOW); //rozopnutie rele
      Serial.println("Rele bolo rozopnute - Vystup neaktivny");
    }

    /*
      float rozdiel2 = nastavena_teplota2 - teplota2;
      if (rozdiel2 > hystereza2) {
      digitalWrite(rele2, HIGH); //zopnutie rele
      } else if (rozdiel2 &lt; (-1 * hystereza2)) {
      digitalWrite(rele2, LOW); //rozopnutie rele
      }
    */
  }
}
</pre>
<h3><font color="#3498DB">Quellcode zum Auflisten der aktuell gemessenen Daten - HTML-Code - ohne Backend</font></h3>
<pre style="background-color:#3498DB;">
          Client handling  
          HTTP header
  int days = millis() / day ;                                //number of days
  unsigned int hours = (millis() % day) / hour;                       //the remainder from days division (in milliseconds) divided by hours, this gives the full hours
  unsigned int minutes = ((millis() % day) % hour) / minute ;         //and so on...
  unsigned int seconds = (((millis() % day) % hour) % minute) / second;
  String stranka = F("&lt;!DOCTYPE html>");
  stranka += F("&lt;html>");
  stranka += F("&lt;head>");
  stranka += F("&lt;meta charset='utf-8'>");
  stranka += F("&lt;meta name='author' content='Martin Chlebovec'>");
  stranka += F("&lt;meta http-equiv='Refresh' content='30'; />");
  stranka += F("&lt;meta name='viewport' content='width=device-width, initial-scale=1'>");
  stranka += F("&lt;link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css'>");
  stranka += F("&lt;script type='text/javascript'>");
  stranka += F("var timeleft = 30;");
  stranka += F("var downloadTimer = setInterval(function(){");
  stranka += F("if(timeleft &lt;= 0){");
  stranka += F("clearInterval(downloadTimer);");
  stranka += F("document.getElementById(\"countdown\").innerHTML = \"Reštart...\";");
  stranka += F("} else {");
  stranka += F("document.getElementById(\"countdown\").innerHTML = timeleft + \" sekúnd do reštartu\";");
  stranka += F("}");
  stranka += F("timeleft -= 1;");
  stranka += F("}, 1000);");
  stranka += F("&lt;/script>");
  stranka += F("&lt;title>WiFi termostat - ESP8266&lt;/title>");
  stranka += F("&lt;/head>");
  stranka += F("&lt;body>");
  stranka += F("&lt;center>&lt;h3>Zadajte dáta pre webserver:&lt;/h3>");
  stranka += F("&lt;form action='/action.html' method='post'>");
  stranka += "&lt;b>Referenčná teplota:&lt;/b>&lt;br>&lt;input type='text' id='fname' name='fname' min='5' max='50' step='0.25' value=" + String(read_String(10)) + ">&lt;br>";
  stranka += "&lt;b>Hysteréza:&lt;/b>&lt;br>&lt;input type='text' id='fname2' name='fname2' min='0' max='10' step='0.25' value=" + String(read_String(100)) + ">&lt;br>";
  stranka += F("&lt;input type='submit' class='btn btn-success' value='Zapísať'>");
  stranka += F("&lt;/form>&lt;hr>");
  if (stav == "ZAP") { //Glob premenna drziaca stav vystupu na zaklade prepoctu mimo HTML stranky
    stranka += F("&lt;b>&lt;font color='green'>Výstup: Zapnutý&lt;/font>&lt;/b>");
  }
  if (stav == "VYP") {
    stranka += F("&lt;b>&lt;font color='red'>Výstup: Vypnutý&lt;/font>&lt;/b>");
  }
  stranka += F("&lt;div id=\"countdown\">&lt;/div>");
  stranka += F("&lt;b>Aktuálna teplota senzora DS18B20:&lt;/b> ");
  stranka += String(teplota);
  stranka += F(" °C");
  stranka += F("&lt;hr>");
  stranka += F("&lt;b>Uptime: &lt;/b>");
  stranka += String(days);
  stranka += F("d");
  stranka += F(" ");
  stranka += String(hours);
  stranka += F("h");
  stranka += F(" ");
  stranka += String(minutes);
  stranka += F("m");
  stranka += F(" ");
  stranka += String(seconds);
  stranka += F("s");
  stranka += F("&lt;h3>Autor: Martin Chlebovec - martinius96@gmail.com - https://martinius96.github.io/WiFi-termostat/&lt;/h3>");
  stranka += F("&lt;h4>Verzia free - 1.0.3 build: 22. Jan. 2021&lt;/h4>");
  stranka += F("&lt;/center>");
  stranka += F("&lt;div class='alert alert-info'>");
  stranka += F("Finálny build projektu WiFi termostat. Ďakujem za vyskúšanie webaplikácie. Rozšírené verzie projektu sú platené.&lt;br>&lt;strong>Obsah platených verzií:&lt;/strong>&lt;li>Async Webserver - AJAX update&lt;/li>&lt;li>Manuálny režim&lt;/li>&lt;li>OTA aktualizácie&lt;/li>&lt;li>Ovládanie hlasom cez Amazon Alexa&lt;/li>&lt;li>Ovládanie cez UDP callbacky&lt;/li>&lt;li>Možnosť publikácie dát na MQTT Broker (Loxone, IoT Industries Slovakia, Blynk...),&lt;/li>&lt;li>Dostupné senzory Bosch, Sensirion, DHT&lt;/li>&lt;li>Watchdog Timer&lt;/li>&lt;li>Zdrojový kód (.ino) pre aplikáciu.&lt;/li>&lt;li>Auto-test periférii, fail-safe riešenie&lt;/li>&lt;li>JSON output rozšírený o systémové dáta (WiFi sieť, RSSI, uptime, napájacie napätie...)&lt;/li>");
  stranka += F("&lt;/div>");
  stranka += F("&lt;/body>");
  stranka += F("&lt;/html>");
	  SEND TO CLIENT
	  FLUSH CLIENT
	  STOP CLIENT
</pre>
<h3><font color="#D35400">Ein Ausschnitt des HTML-Quellcodes einer Seite nach der Verarbeitung von Daten aus einem HTML-Formular</font></h3>
<li> Verwendete die Weiterleitung des Benutzers zurück zur Hauptberichtsseite 5 Sekunden nach der Verarbeitung der in das Formular eingegebenen Daten. </li>
<li> Art der Ladefaulheit. Das Snippet enthält weder ein Backend zur Datenverarbeitung noch funktionale Teile der Website. </li>
<pre style="background-color:#D35400;">
	    Backend_Verarbeitung von Daten aus HTML-Formular
	    .
	    .
	    .
            HTTP header
  String stranka = F("&lt;!DOCTYPE html>");
  stranka += F("&lt;html>");
  stranka += F("&lt;head>");
  stranka += F("&lt;meta charset='utf-8'>");
  stranka += F("&lt;meta http-equiv='Refresh' content='5; url=/' />");
  stranka += F("&lt;title>WiFi termostat - ESP8266 - spracovanie riadiach dát&lt;/title>");
  stranka += F("&lt;/head>");
  stranka += F("&lt;body>");
  stranka += F("&lt;center>&lt;h3>Server prijal data z formulára:&lt;/h3>");
  stranka += "&lt;li>&lt;b>Referenčná teplota: &lt;/b>" + String(read_String(10)) + " °C&lt;/li>";
  stranka += "&lt;li>&lt;b>Hysteréza: &lt;/b>" + String(read_String(100)) + " °C&lt;/li>";
  stranka += F("&lt;b>Presmerovanie... Prosím čakajte&lt;/b>&lt;/center>");
  stranka += F("&lt;/body>");
  stranka += F("&lt;/html>");
	    SEND TO CLIENT
	    FLUSH CLIENT
	    STOP CLIENT
</pre>
</div>
</div>
</body>
</html>
